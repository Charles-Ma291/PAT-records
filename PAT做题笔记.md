# PAT做题笔记

## 甲级大纲

### 在达到乙级要求的基础上，还要求：

1. 具有充分的英文阅读理解能力；

2. 理解并掌握基础数据结构，包括：线性表、树、图；

3. 理解并熟练编程实现经典高级算法，包括哈希映射、并查集、最短路径、拓扑排序、关键路径、贪心、深度优先搜索、广度优先搜索、回溯剪枝等；

4. 具备较强的问题抽象和建模能力，能实现对复杂实际问题的模拟求解。

---

## 一、常用做题单词

- **Integer Factorization**	整数分解

- **Polynomials**			多项式

- **capacity**			容量、限度

- **acyclic**		无环的

- **prefix infix suffix**		前缀 中缀 后缀

- **parenthesis**			括号

- **threshold**		阈值，临界

- **distinct**		不同的，明显的

- **recursive**		递归的

- **alternating**		交替的，交互的

- **repetition**		重复的

- **ascending**		上升的

- **duplication**		重复的，冗余的

  **deduplication**	清除冗余数据.

- **even**		偶数

- **adjacent**		相邻的、相连的

- **permutation**		排列、排序

- **modified**	调整的、修正过的

## 二、知识点

1. **保留n位小数/有效数字**

   头文件`#include<iomanip>`，在想要按格式输出的地方额外添加如下内容

   ```c++
   cout << a;				//正常输出a
   cout << setiosflags(ios::fixed) << setprecision(3) << a;	//保留3位小数
   cout << setprecision(3) << a;			//保留3位有效数字
   ```

   只用记住setp开头几个字母就行

2. **string、char*、char[]、int相互转换**

   char*和char[]可以直接赋值给string类型变量，反过来就不行。

   这是因为string是c++的一个标准库，而char *和char[]里面没有封装更多的对字符串的操作，需要用string类的data() c_str()等函数来把string转化为char *；如果是char[]，则还需要strcpy()字符串拷贝函数。

   ```c++
   string str;
   char* p;
   char arr[10];
   //char* and char[] to string
   str = p;
   str = arr;
   //string to char* and char[]
   strcpy(p, (char*)str.c_str());
   strcpy(arr, (char*)str.c_str());
   //注：把c_str替换为data也可以，但是前者更标准
   ```

   int转化为string可以用to_string()函数，string转化为int用atoi()函数。

   ```c++
   #include<string>	//引入string头文件
   string str = to_string(100);	//"100"
   int i = atoi(str.c_str());		// 100
   ```

3. **多维数组和一维数组的坐标转换**

   把以前的知识忘的一干二净了属于是。多维数组转化为一维数组就是把多维数组一行一行依次平铺——这是行存储，一列一列平铺的叫列存储。

   所以对于一个3 * 4的二位数组，(i, j)坐标的点对应一维数组坐标 x = i * 4 + j。含义：(i, j)表示该点在第i行第j列，每行有4个元素，因此当前元素的编号就是之前的元素个数+1；同理对于3 * 4 * 5（3行4列5面）的三位数组而言，(i, j, k) ==> i * 4 + j + k * 3 * 4

   而一维数组的坐标转化为多维数组只需要乘法与减法。以三维数组为例：

   k = x - x / 3 / 4

   i = (x - k * 3 * 4) / 4

   j = x - k * 3 * 4 - 4 * i

   **记住 坐标 = 元素个数**

4. **二叉树的遍历：前序遍历（preorder）、中序遍历（inorder）、后序遍历（postorder）、层序遍历（levelorder）**

   前序遍历：根左右

   中序遍历：左根右

   后序遍历：左右根

   这三种遍历方式知其二（必须包括中序遍历，不然不唯一）可得另外一种+层序遍历，而其中一种+层序遍历无法求得另外的遍历方式。因为层序遍历不含递归结构，因此能提供的信息太少。

   **如何由两种遍历方式求另一种遍历方式？**（配合PAT 1020食用）输入两行用空格分隔的数字，分别表示两种遍历方式得到的输出结果。当知道两种遍历方式的时候，此时一定可以确定根的位置（记中序遍历为A，另外一种已知的遍历方式为B），不妨设当前采用方式B遍历的树为(x, y)，分别对应树的起点和终点，同理A的树为(m, n)，则树根的位置在B中一定为y-1（后序）或x（前序）。不妨以B方式为后序展开讨论。

   知道树根后找到其在A中的位置，记为index；这个树根将把A树和B树分割为两部分，即左子树和右子树。对于A而言，左子树(x, index)	右子树(index+1, y)；对于B而言，左子树(m, m+index-x)	右子树(m+index-x, n-1)。

   A的划分很简单；因为左子树和右子树在A和B中的长度是一样的，所以可以通过A的划分得到子树长度，再加上起点就可以得到分界点了。由分界点一分为二，注意到最后一个点已经作为树根划分出去了，那么不应该算进去，所以是n-1. 最后递归遍历即可。

5. **格式化输出/输入**

   PAT的输入输出有时候具有很复杂的格式，用cin cout处理就显得很麻烦。这时候就需要用到`printf()`和`scanf()`。注意visual stduio的scanf使用需要忽略报错，否则无法运行。

   ```c
   #pragma warning(disable:4996)
   scanf("%d:%d:%d", &hour, &time, &min);	//输入时间，例如 15:54:04
   printf("%05d", n);	//输出长度为5的数，不足的用0补齐
   printf("%lld", n);	//输出长整数long long
   ```

6. **输入输出流**

   主要研究输入一整行字符串的情形，这里用string类变量来承载输入的字符串。我们使用`getline()`函数，该函数默认的终结符为换行符，而且当碰到终结符的时候它不会将其读入字符串中但会把它从输入流中丢弃，而cin则将其留在输入流中。

   ```c++
   #include<string>
   string str;
   getline(cin, str);	//没有输入长度限制，遇换行结束
   
   string str;
   char a[100];
   cin.getline(a, 5);	//有长度限制的输入不能以string作为参数，但是后面可以直接转换
   str = a;
   ```

   

## 三、经验教训

### 最短路径

思路：基本的数组包括dis和visited分别用于记录源点到别的点的当前最短距离和是否到访过该点。对于多权重比较的情况还需要增加相关的额外数组，在距离相同时比较第二权重；如果需要记录路径则需要构建树，保存当前节点的编号和指向父亲/孩子节点的指针（指向父节点的指针貌似更好做）。

1. 题1003
   - 审题不仔细，把要求输出可行路径条数当成长度（3ac）
   - 当两条路径长度一样时，此时还要进一步进行小队数目的权重比较，但在此之前应先更新道路条数（5ac）
   - 在c1==c2的特殊情况下，由于一开始未对team[c1]赋值（偷懒用res[c1]代替了），导致输出team错误（AC）
   
2. 题1018
   - 理解题意不到位，对于借出和回收不能简单的通过加减来完成（7ac）
   - *编程的时候开x64模式调试，否则可能会引发std::bad_alloc*
   - 编写DFS仍有错误，一直报内存越界，最终未能debug（8ac）

3. 题1030
   - 粗心失误，把cost写成dis白费两小时时间（AC）
   
4. 题1072

   除了一开始没有考虑途径gas的最短路径，可以说一遍过了

5. 题1087

   题意理解偏差，要求输出距离最小的所有路径数（出题人nt）（AC）

### 树

DFS：递归遍历，父节点对每一个孩子调用dfs进行遍历；循环结束表示已经没有可供继续遍历的子节点了，此时把自己pop掉。

BFS：用一个队列维护要遍历的节点，父节点把每一个孩子依次push进队列之中，然后结束循环后把自己pop掉。如果需要知道当前所在的层数的话就维护两个变量，当前节点数cur和下一层节点数next，每pop一下就把cur减一，每push一次就把next加一。当cur等于0的时候把cur赋成next的值并把next置0、level加一。level即为当前层数。

1. 题1013：DFS
   - 一开始把G的列宽设成了边数M，导致循环复杂度上升超时；之后改成点数N正确。以后还是用N*N的数组存储图吧。
2. 题1021：DFS
   - 用邻接矩阵会导致一个测试点超时，改用邻接矩阵的形式（vector< int >G[10005]）
3. 题1034：DFS
   - 审题疏漏，忘记了最后按照人名排序输出，调用algorithm下的sort函数即可（5ac）
   - 这里的N是通话记录数，那么人数在最极端的情况下有2N个。把数组开成1005会段错误（AC）
4. 题1103：DFS
   - algorithm其中的sort的使用：默认是升序排序，可以自己写函数排。写的函数满足如下规则：当我想要让两种元素满足某种关系（我们定义为大于）时，就return true；其他的小于或等于均return false。要特别注意等于的情况，它要return false，不这么写会报错的。
   - 写递归的时候能优化就优化，能尽早结束递归return或循环就尽早。不然一般会超时。

5. 题1131：DFS
   - 一道比较复杂的题，一开始计算两车站距离的时候没考虑到两车站之间不是顺序存储的，即目标车站可能在前也可能在后，应记录位置然后计算绝对值（3ac）
   - 车站编号是0000-9999四位数，不能直接输出int，应进行转化（AC）
   - 解这道题我用了150多行代码，https://blog.csdn.net/liuchuo/article/details/68925193这份答案只用了60多行，思路很清晰，使用了unordermap来保存每两个车站之间的地铁号以便于计算换乘次数，unorderedmap的优势在于可以用数组下标添加元素，降低了代码的复杂度；迭代遍历很清晰，先给出边界条件再进行遍历。

6. 题1091：BFS
   - 比较坑的是题意理解：得把输入的那L片切片看成是一个M * N * L的长方体才行。
   - 每次遍历完联通区域后break会导致运行时间变长，去掉break即可（AC）

7. 题1090：BFS
   - 一道不难的题，但是一开始处理的时候总数num是从1开始计数的，而num的变化取决于level的变化，导致了如果只有一层节点的话f，num就会比实际情况多一（AC）

8. 题1066：AVL

   - 重写平衡二叉树很痛苦，我直接学习大佬的代码再复现（AC）

   - 做有关于树的题一定要利用好递归这个性质！把主要的功能模块封装成函数后递归，这样思路更清晰。因为树相关的很多问题都可以分成这几步处理：

     1. 处理根
     2. 处理左子树
     3. 处理右子树

     顺序可能变化。这种情况就很有利于编写递归的函数结构。另外要注意，如果把指针当作参数传进函数中，那传入的指针其实也和int char一样，程序内部为它开辟一个新的空间。虽然两个指针指向的地址一样，但是函数里的指针不是实参的引用。

     这里写AVL的过程中就有体现：几个主要功能——求高度、左旋、右旋、左旋再右旋、右旋再左旋封装成函数，插入函数传参为待插入的树根和待插值，返回插入完毕并调整好的树根。内部则按照AVL的规则行事：先讨论树根；然后比大小，插入到对应的子树中去；再检查树高是否符合规则并调整，最后返回新树根。

     最后其实都不到100行，最初写的时候写了两百多行还很多bug......

9. 题1110：完全二叉树
   - 完全二叉树的重要性质：每个点的下标从0开始，如果节点x有左孩子，那么左孩子为2x+1；如果有右孩子，下标为2x+2。本题可以对树进行层序遍历，考察每个节点的父亲和自己的下标关系（6ac）
   - 求根节点出现错误：不能一遍就求出根，要在输入完毕后遍历一遍才行。（AC）

10. 题1119：树的遍历

    - 思路很关键：本题依然是由两种遍历求另一种遍历，只不过结果可能不唯一。因此我们需要四个数来表示目前的运行情况：pre中的start、end和post中的start和end。由前序和后序遍历的性质，pre[start]即是当前的树根，在start+1~end这部分则是子树，如果能区分开左子树和右子树，那么当前就是唯一的；如果不能区分开，那么这棵子树既可能是左子树也可能是右子树，情况就不唯一了，我们将视作左子树处理。

      如何区分左子树和右子树？我们不妨记分界点下标为index。start是当前树的树根，由前序遍历的性质，start+1一定是左子树的树根，所以index一定满足post[index]=pre[start+1]。虽然前序和后序遍历的顺序是不一样的，但是包含的节点是一样的。求出index后即可进行划分。（5ac）

    - 要特别考虑边界情况：显然如果当前只有一个点，那就不用对其进行左子树和右子树的构建了；而start==end则直接return；这会出现在当unique=0的时候，右子树就是空的。**其实以后再涉及构建树的代码的时候就先写上什么情况下直接return(start==end, root==NULL)**（AC）

11. 题1135：红黑树
    - 表面上是红黑树，其实是建树+遍历。只是有一个测试点死活过不去，仍在debug（3ac）

12. 题1151：树的遍历
    - 跟上面的1135一样，恶心的一批，好在最后debug出来了，还是学到了很多有价值的东西
    - 这道题都不用建树，只需要看目标节点u v是在哪棵子树或者根上，这里需要用一个map存储值在数组中的位置，这也就引发了第一个易错点：取值。一开始的代码没考虑太多，每次比较都要从map中寻找，导致超时。**用临时变量存储查询的值可以节省大量时间**
    - map的下标运算风险性很大。只要用了下标运算符并且找不到key，那么系统就会自动向里面添加一个key value对，很难发现其中的问题。下次使用map必须多加注意。

### 其他**数据结构**

1. 题1098：堆排序和插入排序

   - 思路和程序的正确性没有问题，我感觉作者不够严谨。这个题我想试着写一下插入排序和堆排序，就把这两个算法分别实现了一遍，然后分别比较每次迭代的结果和中间序列。如果相等就输出。但是这里有一个问题：

     对于输入序列

     ```
     4
     3 4 2 1
     3 4 2 1
     ```

     插入排序的中间结果分别为

     ```
     3 4 2 1
     3 4 2 1
     2 3 4 1
     1 2 3 4
     ```

     那么如果是第一个结果的话，那它的下一次遍历结果还是3 4 2 1，而不是答案认为的2 3 4 1.

     所以这里其实应该输出最后一次出现的下一次结果，但是出题人并没有说这种情况，白白浪费我3小时debug，出题人nmsl

2. 题1107：并查集

   - 并查集的题也是有规律可循的，但是做这道题之前我并没有了解，就想用最基本的循环遍历来合并集合，但是最后一直过不去一个测试点，debug好久无果（还是要细心编程，不然都不知道错哪），最后只能学习更好的办法。

   - 并查集一个重要的特性就是找一个元素来代表这个集合（father），集合里的其他元素都指向他。本题目集合里面存的是人，而爱好（hobby）只是用来对人进行划分的属性。

     如何在爱好和人之间建立关系？因为一个集合里面的人都有共同的爱好，而如果集合外的人也有这些爱好之一，那么他也应该被纳入其中。所以我们让爱好指向这个集合里的人——不一定是father，任何一个人都可以，反正我们也能找到father。

     如果集合A里面的成员和集合B里面的成员有相交的爱好，那么我们就将把两个集合合并（Union），其实就是把A里面每个元素的father改成B的father。把B的改成A也行。

   - 解题切忌浮躁，有不会的知识点就老实找大佬的代码学习，不一定非要改出来bug才行。

3. 题1118：并查集

   - 关于father和findFather：Union和findFather每次都会对father进行更新，但是father仍不是实时准确的，所以在计算Count的时候仍要用findFather。这一次更新过后father就指向每棵树唯一的值了，不存在指向中间节点的情况了，之后就可以使用father而不是findFather。
   - 再重申一下几个数组的意义：tree是靠bird来进行划分的，每棵树都有一个bird代表，即`tree[i]=cur_bird`。意思是cur_bird就代表了第i棵树，合并的时候就合并cur_bird和tree[i]，就表示把cur_bird代表的树和第i棵树进行合并。
   
4. 题1014：队列

   - 一道比较复杂的题，考察编写代码的逻辑严密性。这道题还有一个坑就是题意理解：题目说的是对于17：00后还没开始服务的人恕不接待，但是17：00前就已经开始处理的无论多久都要处理完毕，所以要用两个数组保存时间关系：开始时间和结束时间，开始时间用于判断，结束时间用于输出。（2ac）
   - 一开始的时候报段错误，后来发现是代码不严谨：对于窗口数大于人数的情况，那么有些窗口一开始就是空的，而这时候依然对windows求下标，就会出界。（AC）
   - 本题思路：先把黄线前的占满，然后找时间最小的窗口→（判断窗口非空）更新结束时间，窗口pop→（判断顾客非空）添加顾客→（判断窗口非空）更新交易时间，start

5. 题1056：队列

   - 我没看出来这道题跟队列有啥关系.......我是用vector做的，vector在排序和添加元素的时候非常方便，可能用queue也行吧。
   - 这道题一开始写的就基本对了，但是比较函数cmp出了问题，因为rank一开始都是0，所以就会有很多无用元素。要再进行二次比较。

6. 题1052：链表
   - 这道题比较离谱，我一开始怎么都不能理解如果有两个点指向同一个点该怎么办，后来发现不管它就得了呗...属于是想的太多了
   - 这道题反映出编码逻辑严密性还有待提升，有好多特殊情况都没考虑到：链表不存在怎么办，输出的head地址有没有用5位表示等等。

7. 题1074：链表

   - 得注意考虑边界问题，当i==N-1的时候还可能得做一次reverse。

8. 题1133：链表

   - 写的代码复杂度拉满，好在一遍过了，不然我可不会debug。考试的时候要记得多多保存中间结果，这样用起来会很方便。

9. 题1122：图论

   - 主要考察对定义的分析，需要搞清楚什么是circle，什么是Hamilton circle。过了样例就基本行了。

10. 题1126：图论

    - 这道题首先是忽略了图不连通的情况，其次在判断图的连通性的时候，编写的递归函数出现了超时的问题，经分析后发现可能是递归中写了过多的if语句导致时间变长。所以递归函数的语句能省则省。

11. 题1142：图论

    - 总结规律：图论的题还是偏简单的（因为难的根本不会），需要注意的就是别把变量搞混写错了，还有就是一定要理解题意，搞清楚要干嘛之后在写。

      上来先建一个vector数组和二维数组用来表示边，前者是为了更快的找到一个顶点有哪些边；后者是快速定位两点间是否有边。这能大大降低用时；

      视需要选择visited和exist数组，前者用来记录遍历过的点，后者用来保存子图都有哪些点。没有什么固定算法，掌握DFS和BFS就行了。

12. 题1150：图论

    - 再补充一个定义吧，什么是环（cycle）和简单环（simple cycle）

      所有的环的首元素和尾元素都必须一样，首尾不一样不叫cycle；简单环则是只允许首尾一样，中间不途径重复节点的环。做题的时候还要注意他给的路径存不存在。

13. 题1146：拓扑排序
    - 需要两个vector数组用来存边：一个正常存，还有一个存被指向的边。后者是为了方便检查现在是否不被指向，前者是为了方便清除过程——遍历一个点后要更新数组。

### 排序

1. 题1016
   - 把这道题想的复杂了，最后把自己绕晕了都不想debug。简化处理方式：不需要为人名创建什么特殊的结构，直接存然后按照字符串和时间排序即可。简化处理时间：算每个时间点到00:00:00:00的距离再相减即可。
2. 题1025
   - 还是不太会做模拟的题，有时候定义了太多的结构体和数组，最后搞的不知道哪个是哪个了。还是得想办法简化变量。

3. 题1141
   - 一道比较恶心的题，要点在于计算TWS的时候必须按照double计算，而比较和输出的时候就得按照int输出，其实还是理解题意的问题，题目说了 which is defined to be the integer part of，还是自己粗心了

### 字符串

1. 题1024
   - 字符串处理用string会非常方便；进位问题是难点：如何处理进位？设一个flag位为当前位是否有进位，有进位就加一；然后 看当前位是否大于等于10并更新flag，记住要模10；如何扩展？从数组的末尾向前遍历并设置起始位start，当出现最高进位时把start-1，这里要考虑最大的位数以防start减成负数。
   
2. 题1060

   - 这道题可谓是解的跌跌撞撞，我也在不断的摸索和改进中完善对题意的理解。

   - 用科学计数法表示小数，题目要求我们输出成0.xxxx的形式，而xxxx就是从第一个非零位开始向后数至N位。那么可以知道有两个变量需要维护：第一个非零位的位置start和小数点位置dot。而这个数的指数exp则可以由start和dot计算而得。

   - 先说保存小数的问题。dot初始化为末尾，遍历一遍看到点了就break；start则初始化为dot，表示如果没有非零数那么小数部分就都是0，遍历一遍不为0不为点就break。

     求出两个参数后就可以开始保存小数部分了，从start开始向后遍历N位，注意如果遍历到点了，应该保存其后的数位，以后也要加一。（坑）

   - 再说计算exp的问题，又是一个坑。如果是正指数或0的话exp就等于dot-start（小数点向前移动）；但如果是负指数的话exp等于dot-start+1（小数点移动到非零数之前）。

3. 题1061
   - 玩文字游戏的傻逼题

### 其他题型

1. 题1007：动态规划
   - 准确找出动态规划的点并不容易，还需要做更多的题。这题我一开始的时候开二维数组计算，导致时间复杂度过高，改用dp解决问题
   - 动规公式 dp[i] = dp[i-1] + num[i]，要注意当dp[i]小于0的时候就应该舍弃它，因为一个负数只会拉低sum。具体解题的时候设两个求和变量cur sum，cur用于更新sum，当cur小于0的时候就把它置零并更新它的位置。
2. 题1040：动态规划
   - 我想的方法一开始就错了，还得是学习了柳神的方法：用i ，j表示是否是对称串，考虑到状态转移问题，用子串初始位置和子串长度进行枚举，保证每一次遍历都求出这个长度的对称子串。
3. 题1017：模拟
   - 做这种题要把思路捋顺，柳神的思路非常巧妙，首先将时间都转化为秒数，就只需用一个int存，不过这样要记得将等待的时间乘60，最后除60
   - 除了输入的数组外，程序只维护了一个优先队列(priority_queue)，队列的大小为K，里面存的数L表示到L之后就可以服务了，而优先队列里面的元素都按照从小到大排列，以保证队列顶部的元素就是最先提供服务的时间。因此不需要维护全局时间变量，只需要遍历用户数组，每次判定：当用户到达的时间早于队列顶部的时间的时候，意味着此时不能为他提供服务，需要等待`q.top()-arrive`的时间，然后在队列底部插入该用户结束服务的时间，即`q.top()+p`，同时弹出队顶元素；当用户到达的时间晚于队列顶部时间的时候，此时可以直接提供服务，直接在插入结束时间`arrive+p`并弹出队顶即可。

## 复习

最后需要回顾的点有：最短路径、DFS、并查集、简单的图论、动态规划、二分查找、贪心算法

一、最短路径

基本思路：记录第一权重（距离）和路径（father vector），然后深度遍历路径寻找第二权重下的待求解。可参看1003

```c++
void dijsktra()
{
    bool visited[Num_node]={0};//已知的最短路径点
    int dis[Num_node]={0x3fffffff};//已知的最短路径点的距离
    for(){/*init: 根据已有图更新dis*/}
    while(!visited[to])
    {
        int index, mindis;
        for(){/*根据已有信息找到距离源点最短的点index和相应的距离mindis*/}
        visited[index]=1;	//这就是最短路径了
        for()//根据index更新dis和father
        {
            if(/*距离更小*/)
            {/*清空father*/}
            else /*距离相等*/
            {/*更新father*/}
        }
	}
}

void dfs(/*第二权重参数*/)
{
    if(cur_node==from)
    {
        /*保存题目要求的信息*/
        return;
	}
    for(int i=0;i<father[cur_node].size();i++)
    {
        dfs();
    }
}
```

仿照该思路做1018满分，但犯了两个毛病：在dijsktra的时候判断距离中忘了考虑两点之间是否联通，即road\[i]\[j]!=0；cpath什么时候popback没有搞清楚。

二、并查集

并查集的特点：每个元素都有各自的若干属性，而根据这些属性可以把它们划分到若干集合中去，划分依据就是存在相同的属性，所以这里要建立两个数组：元素数组，里面存放每个元素指向对应集合的根节点，初始化为自己；属性数组，里面存放着拥有该属性的元素（不一定是根节点），初始化为0（-1）.

基本思路：不妨记元素数组为p，属性数组为att。在输入阶段每输入一个属性的时候判断当前属性是否已指向了一个元素，如果有指向就将这两个元素集合合并；没有指向就指向当前元素。

```c++
int getFather(int x)
{
    int prev=0, curr=x, f;
    while(prev!=curr)
    {
		prev = curr;
         curr = p[curr]->father;
    }
    prev=0, curr=x, f=curr;	//根节点
    while(prev!=curr) //再次循环以更新路径上的节点，降低层数
    {
		prev = curr;
         curr = p[curr]->father;
         p[curr]->father = f;
    }
}

int main()
{
	for(int i=1;i<=N;i++)//N是元素个数, 如果从0开始那属性数组就要初始化为0
    {
		int n, a;	cin>>n;	//n是每个元素属性个数
        for(int j=0;j<n;j++)
        {
			cin>>a;		//该节点的一个属性
            if(att[a]==0)//该属性未有指向
                att[a]=i;
            else//有指向，合并
            {
                int fa = getFather(p[att[a]]), fb=getFather(p[i]);
                p[fa]->father=fb;
                getFather[p[i]];	//更新路径的father
            }
        }
    }
    //这里要注意，即使已经“更新”了father，每个元素指向的father仍不一定是根节点的值，后面寻找根节点还是要调用getFather.
}
```

